name: Android Build & Smoke Test

env:
  NODE_OPTIONS: --openssl-legacy-provider
  ADB_INSTALL_TIMEOUT: 20
  SMOKE_SOFT_FAIL: ${{ github.event.inputs.smoke_soft_fail }}
  ANDROID_BUILD_TOOLS: "31.0.0"
  ANDROID_SERIAL: emulator-5554

on:
  workflow_dispatch:
    inputs:
      smoke_soft_fail:
        description: "Mark smoke test neutral on failure (upload logs anyway)"
        required: false
        default: "false"
  push:
    branches:
      - main
      - develop
      - feat/ccpm-framework
  pull_request:
    branches:
      - main
      - develop

jobs:
  build:
    name: Build APKs
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java 11 (Gradle)
        id: j11
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '11'

      - name: Setup Java 17 (sdkmanager tools)
        id: j17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Verify Java toolchains
        shell: bash
        run: |
          echo "Gradle should use Java 11:"
          "${{ steps.j11.outputs.path }}/bin/java" -version
          echo "sdkmanager should use Java 17:"
          "${{ steps.j17.outputs.path }}/bin/java" -version


      - name: Bootstrap Android cmdline-tools r8 (8092744)
        shell: bash
        env:
          JAVA_HOME: ${{ steps.j17.outputs.path }}
        run: |
          set -euo pipefail
          # Prepare SDK root
          export ANDROID_SDK_ROOT="$HOME/android-sdk"
          mkdir -p "$ANDROID_SDK_ROOT/cmdline-tools"
          cd "$ANDROID_SDK_ROOT"

          # Download cmdline-tools r8 (8092744) for macOS/Linux
          # macOS and Linux use same archive name pattern; mac runners need 'darwin', ubuntu 'linux'
          OS=$(uname | tr '[:upper:]' '[:lower:]')
          if [[ "$OS" == "darwin" ]]; then
            URL="https://dl.google.com/android/repository/commandlinetools-mac-8092744_latest.zip"
          else
            URL="https://dl.google.com/android/repository/commandlinetools-linux-8092744_latest.zip"
          fi

          curl -fsSL "$URL" -o cmdtools.zip
          unzip -q cmdtools.zip -d cmdline-tools-tmp
          # Move to canonical 'cmdline-tools/r8'
          mkdir -p "$ANDROID_SDK_ROOT/cmdline-tools/r8"
          mv cmdline-tools-tmp/cmdline-tools/* "$ANDROID_SDK_ROOT/cmdline-tools/r8/"
          rm -rf cmdline-tools-tmp cmdtools.zip

          # Path wiring to ensure we always use r8 sdkmanager
          echo "$ANDROID_SDK_ROOT/cmdline-tools/r8/bin" >> "$GITHUB_PATH"
          echo "$ANDROID_SDK_ROOT/platform-tools" >> "$GITHUB_PATH"
          echo "ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT" >> "$GITHUB_ENV"
          
          # Set local.properties for Gradle
          echo "sdk.dir=$ANDROID_SDK_ROOT" > ${{ github.workspace }}/android/local.properties

      - name: Accept SDK licenses (r8)
        shell: bash
        env:
          JAVA_HOME: ${{ steps.j17.outputs.path }}
        run: |
          set -euo pipefail
          echo "Accepting SDK licenses non-interactively..."
          ( echo "y"; echo "y"; echo "y"; echo "y"; echo "y"; echo "y"; echo "y"; echo "y" ) | sdkmanager --licenses || true

      - name: Install platform-tools + build-tools + emulator + platforms (r8)
        shell: bash
        env:
          JAVA_HOME: ${{ steps.j17.outputs.path }}
        run: |
          set -euo pipefail
          sdkmanager --install "platform-tools" \
            "build-tools;${{ env.ANDROID_BUILD_TOOLS }}" \
            "emulator" \
            "platforms;android-31" \
            "system-images;android-30;default;x86_64"
          # Prove r8 is in effect and apksigner exists at pinned version
          "${ANDROID_SDK_ROOT}/build-tools/${{ env.ANDROID_BUILD_TOOLS }}/apksigner" --version

      - name: Print versions
        env:
          JAVA_HOME: ${{ steps.j11.outputs.path }}
        run: |
          echo "JAVA (Gradle):" && java -version
          echo "Gradle wrapper:" && ./android/gradlew -v
          echo "SDK Root: $ANDROID_SDK_ROOT"

      - name: Use Node 18 (with npm cache)
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Prime Gradle cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
            android/.gradle
          key: gradle-${{ runner.os }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            gradle-${{ runner.os }}-

      - name: Ensure Gradle build cache on
        run: |
          mkdir -p ~/.gradle
          {
            echo "org.gradle.caching=true"
            echo "org.gradle.parallel=false"
          } >> ~/.gradle/gradle.properties
          
      - name: Install Node dependencies
        run: npm install --legacy-peer-deps

      - name: Install TrackPlayer stub (TEMP for CI)
        run: |
          # Create TrackPlayer stub for CI builds
          mkdir -p node_modules/react-native-track-player
          cat > node_modules/react-native-track-player/package.json << 'EOF'
          {
            "name": "react-native-track-player",
            "version": "0.0.0-stub",
            "description": "Temporary stub for react-native-track-player (CI build only)",
            "main": "index.js",
            "private": true
          }
          EOF
          cat > node_modules/react-native-track-player/index.js << 'EOF'
          // TEMP STUB: react-native-track-player disabled for CI build
          const TrackPlayer = {
            setupPlayer: async () => console.log('TrackPlayer stub: setupPlayer called'),
            stop: async () => console.log('TrackPlayer stub: stop called'),
            getTrack: async () => null,
            getState: async () => 'idle',
            getPosition: async () => 0,
            play: async () => {},
            pause: async () => {},
            reset: async () => {},
            add: async () => {},
            skip: async () => {},
            skipToNext: async () => {},
            skipToPrevious: async () => {},
            remove: async () => {},
            destroy: async () => {},
            updateOptions: async () => {},
            updateMetadataForTrack: async () => {},
            getQueue: async () => [],
            getCurrentTrack: async () => null,
            getDuration: async () => 0,
            getBufferedPosition: async () => 0,
            getVolume: async () => 1,
            setVolume: async () => {},
            getRate: async () => 1,
            setRate: async () => {},
            seekTo: async () => {},
            setRepeatMode: async () => {},
            getRepeatMode: async () => 0,
          };
          export default TrackPlayer;
          EOF
          echo "TrackPlayer stub installed for CI build"

      - name: Make Gradle wrapper executable
        run: chmod +x ./android/gradlew

      - name: Build Debug & Release (with build watchdog)
        env:
          JAVA_HOME: ${{ steps.j11.outputs.path }}
          NODE_OPTIONS: --openssl-legacy-provider
          GRADLE_OPTS: "-Dorg.gradle.daemon=true -Dorg.gradle.jvmargs='-Xmx3g -XX:+HeapDumpOnOutOfMemoryError' -Dorg.gradle.workers.max=2"
        run: |
          set -e
          cd android
          
          # Build watchdog function with diagnostics
          build_with_watchdog() {
            local task="$1"
            local timeout_min=25
            ./gradlew "$task" --build-cache --no-parallel --stacktrace &
            local gradle_pid=$!
            
            # Monitor build progress
            local elapsed=0
            while kill -0 $gradle_pid 2>/dev/null; do
              sleep 60
              elapsed=$((elapsed + 1))
              echo "📊 Build progress: ${elapsed}min / ${timeout_min}min"
              
              if [ $elapsed -ge $timeout_min ]; then
                echo "❌ Build timeout after ${timeout_min}min - killing Gradle"
                kill -9 $gradle_pid 2>/dev/null || true
                
                # Diagnostic dump
                echo "🔍 Process tree at timeout:"
                pgrep -f gradle | xargs -r ps -fp || true
                echo "🔍 Gradle daemon status:"
                ./gradlew --status || true
                echo "🔍 System load:"
                uptime || true
                
                exit 1
              fi
            done
            
            wait $gradle_pid
            echo "✅ Build completed in ${elapsed}min"
          }
          
          build_with_watchdog ":app:assembleDebug"
          build_with_watchdog ":app:assembleRelease"

      - name: Print artifact sizes
        run: |
          ls -lh android/app/build/outputs/apk/debug/*.apk  || true
          ls -lh android/app/build/outputs/apk/release/*.apk || true

      - name: Upload Debug APK
        uses: actions/upload-artifact@v4
        with:
          name: app-debug-apk
          path: android/app/build/outputs/apk/debug/*.apk
          retention-days: 14

      - name: Upload Release APK
        uses: actions/upload-artifact@v4
        with:
          name: app-release-apk
          path: android/app/build/outputs/apk/release/*.apk
          retention-days: 14

      - name: Extract SDK + sizes from manifest/APKs
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          export ANDROID_SDK_ROOT="${ANDROID_SDK_ROOT:-${ANDROID_HOME:-}}"
          echo "${ANDROID_SDK_ROOT}/build-tools/31.0.0" >> "$GITHUB_PATH"
          echo "${ANDROID_SDK_ROOT}/platform-tools" >> "$GITHUB_PATH"

          APK_DEBUG="$(ls -1 android/app/build/outputs/apk/debug/*.apk | head -n1)"
          APK_RELEASE="$(ls -1 android/app/build/outputs/apk/release/*.apk | head -n1)"

          # Use aapt2 if available, else aapt
          AAPT="$(command -v aapt2 || true)"
          [ -z "$AAPT" ] && AAPT="$(command -v aapt || true)"

          # Fallback to apkanalyzer if needed
          if [ -n "$AAPT" ]; then
            MIN_SDK="$($AAPT dump badging "$APK_DEBUG" | sed -n "s/.*sdkVersion:'\([^']*\)'.*/\1/p" | head -n1)"
            TGT_SDK="$($AAPT dump badging "$APK_DEBUG" | sed -n "s/.*targetSdkVersion:'\([^']*\)'.*/\1/p" | head -n1)"
          else
            MIN_SDK="$(apkanalyzer manifest min-sdk "$APK_DEBUG" || true)"
            TGT_SDK="$(apkanalyzer manifest target-sdk "$APK_DEBUG" || true)"
          fi

          DBG_MB="$(( $(stat -c%s "$APK_DEBUG" 2>/dev/null || stat -f%z "$APK_DEBUG") / 1024 / 1024 ))"
          REL_MB="$(( $(stat -c%s "$APK_RELEASE" 2>/dev/null || stat -f%z "$APK_RELEASE") / 1024 / 1024 ))"

          echo "SDK_MIN=$MIN_SDK" >> $GITHUB_ENV
          echo "SDK_TARGET=$TGT_SDK" >> $GITHUB_ENV
          echo "APK_DEBUG_MB=$DBG_MB" >> $GITHUB_ENV
          echo "APK_RELEASE_MB=$REL_MB" >> $GITHUB_ENV

      - name: Ensure build-tools for apksigner/aapt
        shell: bash
        run: |
          set -euo pipefail
          export ANDROID_SDK_ROOT="${ANDROID_SDK_ROOT:-${ANDROID_HOME:-}}"
          if [ -z "${ANDROID_SDK_ROOT}" ] || [ ! -d "${ANDROID_SDK_ROOT}" ]; then
            echo "❌ ANDROID_SDK_ROOT not set or invalid"; exit 1
          fi

          # Use the build-tools version already installed
          echo "${ANDROID_SDK_ROOT}/build-tools/${{ env.ANDROID_BUILD_TOOLS }}" >> "$GITHUB_PATH"

          "${ANDROID_SDK_ROOT}/build-tools/${{ env.ANDROID_BUILD_TOOLS }}/apksigner" version

      - name: Gather APK metadata (debug + release)
        id: apkmeta
        shell: bash
        run: |
          mkdir -p artifacts/meta
          DBG=$(ls android/app/build/outputs/apk/debug/*.apk | head -n1)
          REL=$(ls android/app/build/outputs/apk/release/*.apk | head -n1 || true)

          # Prefer aapt, fallback apkanalyzer
          meta() {
            local APK="$1" ; local OUT="$2"
            if [ -z "$APK" ] || [ ! -f "$APK" ]; then return 0; fi
            if command -v aapt >/dev/null 2>&1; then
              {
                echo "APK=$APK"
                aapt dump badging "$APK"
              } > "$OUT" || true
            elif command -v apkanalyzer >/dev/null 2>&1; then
              {
                echo "APK=$APK"
                apkanalyzer manifest print "$APK"
              } > "$OUT" || true
            fi
          }

          meta "$DBG" artifacts/meta/debug_badging.txt
          meta "$REL" artifacts/meta/release_badging.txt

          # Write outputs for later steps
          echo "debug_apk=$DBG" >> $GITHUB_OUTPUT
          echo "release_apk=$REL" >> $GITHUB_OUTPUT

      - name: Verify Release APK signing
        if: ${{ steps.apkmeta.outputs.release_apk != '' }}
        shell: bash
        run: |
          apksigner verify --print-certs "${{ steps.apkmeta.outputs.release_apk }}"

      - name: APK size guard
        shell: bash
        run: |
          DBG=${{ steps.apkmeta.outputs.debug_apk }}
          REL=${{ steps.apkmeta.outputs.release_apk }}
          mkdir -p artifacts/meta
          summary="$GITHUB_STEP_SUMMARY"

          sz() { [ -f "$1" ] && stat -c%s "$1" || echo 0; }
          DBG_SIZE=$(sz "$DBG")
          REL_SIZE=$(sz "$REL")

          # Thresholds (adjustable)
          DBG_MAX=$((120 * 1024 * 1024))   # 120 MB
          REL_MAX=$((80 * 1024 * 1024))    # 80 MB

          echo "## APK Size" >> "$summary"
          echo "- Debug: $((DBG_SIZE/1024/1024)) MB" >> "$summary"
          if [ -f "$REL" ]; then
            echo "- Release: $((REL_SIZE/1024/1024)) MB" >> "$summary"
          fi

          WARN=0
          if [ "$DBG_SIZE" -gt "$DBG_MAX" ]; then echo "⚠️ Debug APK exceeds ${DBG_MAX} bytes" >> "$summary"; WARN=1; fi
          if [ -f "$REL" ] && [ "$REL_SIZE" -gt "$REL_MAX" ]; then echo "⚠️ Release APK exceeds ${REL_MAX} bytes" >> "$summary"; WARN=1; fi

          # Do not fail build; just warn (flip to hard fail later if desired)
          exit 0

      - name: SDK sanity (min/target)
        shell: bash
        run: |
          summary="$GITHUB_STEP_SUMMARY"
          FILE="artifacts/meta/debug_badging.txt"
          if [ -f "$FILE" ]; then
            MIN=$(grep -Eo "sdkVersion:'.*'|uses-sdk:minSdkVersion:'[0-9]+'" "$FILE" | head -n1 | sed "s/.*'//;s/'//")
            TGT=$(grep -Eo "targetSdkVersion:'[0-9]+'" "$FILE" | head -n1 | sed "s/.*'//;s/'//")
            echo "## SDK" >> "$summary"
            echo "- minSdk: \`${MIN:-unknown}\`" >> "$summary"
            echo "- targetSdk: \`${TGT:-unknown}\`" >> "$summary"
          fi

      - name: Upload metadata artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-metadata
          path: artifacts/meta/**
          retention-days: 14

      - name: Publish run identifiers
        if: always()
        shell: bash
        run: |
          echo "${GITHUB_RUN_ID}" > RUN_ID.txt
          echo "${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}" > RUN_URL.txt

      - name: Upload run identifiers
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ids
          path: |
            RUN_ID.txt
            RUN_URL.txt

  smoke-test:
    name: Android Smoke (macOS HVF)
    needs: build
    runs-on: macos-13
    timeout-minutes: 35
    env:
      NODE_OPTIONS: --openssl-legacy-provider
      ADB_INSTALL_TIMEOUT: 20
      ANDROID_SERIAL: emulator-5554
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java 11 (primary)
        id: j11
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '11'

      - name: Setup Java 17 (sdkmanager tools)
        id: j17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Verify Java toolchains
        shell: bash
        run: |
          echo "macOS Gradle (if needed) uses Java 11:"
          "${{ steps.j11.outputs.path }}/bin/java" -version
          echo "macOS sdkmanager uses Java 17:"
          "${{ steps.j17.outputs.path }}/bin/java" -version


      - name: Bootstrap Android cmdline-tools r8 (8092744)
        shell: bash
        env:
          JAVA_HOME: ${{ steps.j17.outputs.path }}
        run: |
          set -euo pipefail
          # Prepare SDK root
          export ANDROID_SDK_ROOT="$HOME/android-sdk"
          mkdir -p "$ANDROID_SDK_ROOT/cmdline-tools"
          cd "$ANDROID_SDK_ROOT"

          # Download cmdline-tools r8 (8092744) for macOS/Linux
          # macOS and Linux use same archive name pattern; mac runners need 'darwin', ubuntu 'linux'
          OS=$(uname | tr '[:upper:]' '[:lower:]')
          if [[ "$OS" == "darwin" ]]; then
            URL="https://dl.google.com/android/repository/commandlinetools-mac-8092744_latest.zip"
          else
            URL="https://dl.google.com/android/repository/commandlinetools-linux-8092744_latest.zip"
          fi

          curl -fsSL "$URL" -o cmdtools.zip
          unzip -q cmdtools.zip -d cmdline-tools-tmp
          # Move to canonical 'cmdline-tools/r8'
          mkdir -p "$ANDROID_SDK_ROOT/cmdline-tools/r8"
          mv cmdline-tools-tmp/cmdline-tools/* "$ANDROID_SDK_ROOT/cmdline-tools/r8/"
          rm -rf cmdline-tools-tmp cmdtools.zip

          # Path wiring to ensure we always use r8 sdkmanager
          echo "$ANDROID_SDK_ROOT/cmdline-tools/r8/bin" >> "$GITHUB_PATH"
          echo "$ANDROID_SDK_ROOT/platform-tools" >> "$GITHUB_PATH"
          echo "ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT" >> "$GITHUB_ENV"

      - name: Accept SDK licenses (r8)
        shell: bash
        env:
          JAVA_HOME: ${{ steps.j17.outputs.path }}
        run: |
          set -euo pipefail
          echo "Accepting SDK licenses non-interactively..."
          ( echo "y"; echo "y"; echo "y"; echo "y"; echo "y"; echo "y"; echo "y"; echo "y" ) | sdkmanager --licenses || true

      - name: Install platform-tools + build-tools + emulator + platforms (r8)
        shell: bash
        env:
          JAVA_HOME: ${{ steps.j17.outputs.path }}
        run: |
          set -euo pipefail
          sdkmanager --install "platform-tools" \
            "build-tools;${{ env.ANDROID_BUILD_TOOLS }}" \
            "emulator" \
            "platforms;android-31" \
            "system-images;android-30;default;x86_64"
          # Prove r8 is in effect and apksigner exists at pinned version
          "${ANDROID_SDK_ROOT}/build-tools/${{ env.ANDROID_BUILD_TOOLS }}/apksigner" --version

      - name: ADB hygiene (macOS) + serial pinning
        shell: bash
        run: |
          set -euo pipefail
          # Kill any stray adb and remove stale lock/state
          pkill -9 adb || true
          adb kill-server || true
          rm -f "${HOME}/.android/adbkey" "${HOME}/.android/adbkey.pub" || true
          rm -rf "${HOME}/.android/adb*" || true

          # Fresh server from our platform-tools
          adb start-server
          adb devices -l || true
          
          # Pin ADB serial for all subsequent operations
          echo "🔒 ADB pinned to serial: ${{ env.ANDROID_SERIAL }}"

      - name: Download Debug APK
        uses: actions/download-artifact@v4
        with:
          name: app-debug-apk
          path: artifacts/debug

      - name: Download Release APK
        uses: actions/download-artifact@v4
        with:
          name: app-release-apk
          path: artifacts/release

      - name: Find APK and set env
        run: |
          APK=$(find artifacts/debug -name "*.apk" -type f | head -1)
          if [ -z "$APK" ]; then
            echo "No APK found under artifacts/debug"
            exit 1
          fi
          echo "APK=$APK" | tee -a "$GITHUB_ENV"

      - name: Create AVD and start emulator (with boot watchdog)
        shell: bash
        run: |
          set -euo pipefail
          
          # Create AVD
          echo "no" | avdmanager create avd -n test_avd -k "system-images;android-30;default;x86_64" --device "pixel_5" --force
          
          # Start emulator with fixed port mapping
          $ANDROID_SDK_ROOT/emulator/emulator @test_avd -no-window -no-audio -no-boot-anim -memory 1024 -accel hvf -ports 5554,5555 &
          EMU_PID=$!
          echo "emulator_pid=$EMU_PID" >> $GITHUB_ENV
          
          # Boot watchdog with clean failure
          boot_watchdog() {
            local timeout_min=15
            local elapsed=0
            
            echo "⏰ Starting emulator boot watchdog (${timeout_min}min timeout)"
            
            # Wait for ADB device to appear
            while ! adb -s ${{ env.ANDROID_SERIAL }} get-state >/dev/null 2>&1; do
              sleep 5
              elapsed=$((elapsed + 1))
              
              if [ $elapsed -ge $((timeout_min * 12)) ]; then  # 5s intervals = 12 per minute
                echo "❌ Emulator never appeared on ADB within ${timeout_min}min"
                echo "🔍 Final diagnostics:"
                adb devices -l || true
                ps aux | grep emulator || true
                kill -9 $EMU_PID 2>/dev/null || true
                exit 1
              fi
              
              # Progress every minute
              if [ $((elapsed % 12)) -eq 0 ]; then
                echo "📊 Boot progress: $((elapsed/12))min / ${timeout_min}min"
                adb devices || true
              fi
            done
            
            # Wait for sys.boot_completed
            elapsed=0
            while ! adb -s ${{ env.ANDROID_SERIAL }} shell getprop sys.boot_completed 2>/dev/null | grep -qx '1'; do
              sleep 5
              elapsed=$((elapsed + 1))
              
              if [ $elapsed -ge $((timeout_min * 12)) ]; then
                echo "❌ sys.boot_completed not reached within ${timeout_min}min"
                echo "🔍 Boot properties:"
                adb -s ${{ env.ANDROID_SERIAL }} shell getprop | grep -E 'boot|init' || true
                kill -9 $EMU_PID 2>/dev/null || true
                exit 1
              fi
              
              if [ $((elapsed % 12)) -eq 0 ]; then
                echo "📊 Boot progress: $((elapsed/12))min / ${timeout_min}min"
              fi
            done
            
            echo "✅ Emulator boot completed in $((elapsed/12)).$((elapsed%12*5))min"
          }
          
          boot_watchdog
          
          # Final verification with pinned serial
          adb -s ${{ env.ANDROID_SERIAL }} shell input keyevent 82 || true
          adb -s ${{ env.ANDROID_SERIAL }} devices -l
      

      - name: Guardrail adb from our SDK
        shell: bash
        run: |
          set -euo pipefail
          ADB_BIN="$(command -v adb || true)"
          echo "adb = $ADB_BIN"
          echo "$ADB_BIN" | grep -q "${ANDROID_SDK_ROOT}/platform-tools/adb" || { echo "❌ adb not from expected SDK"; exit 1; }

      - name: Ensure build-tools (smoke)
        shell: bash
        run: |
          set -euo pipefail
          export ANDROID_SDK_ROOT="${ANDROID_SDK_ROOT:-${ANDROID_HOME:-}}"
          if [ -z "${ANDROID_SDK_ROOT}" ] || [ ! -d "${ANDROID_SDK_ROOT}" ]; then
            echo "❌ ANDROID_SDK_ROOT not set or invalid"; exit 1
          fi

          echo "${ANDROID_SDK_ROOT}/build-tools/${{ env.ANDROID_BUILD_TOOLS }}" >> "$GITHUB_PATH"

      - name: Install Debug APK
        shell: bash
        run: |
          echo "Installing APK..."
          adb -s ${{ env.ANDROID_SERIAL }} install -r "$APK"

      - name: Determine package + launchable activity (robust)
        id: pkg
        shell: bash
        run: |
          set -euo pipefail
          # APK is already set from "Find APK and set env" step
          echo "apk=$APK" >> $GITHUB_OUTPUT

          # Generate APK metadata for logs
          mkdir -p artifacts/logs
          if command -v aapt >/dev/null 2>&1; then
            aapt dump badging "$APK" | tee artifacts/logs/apk_badging.txt
          fi

          # Prefer aapt, fallback to apkanalyzer
          if command -v aapt >/dev/null 2>&1; then
            PKG=$(aapt dump badging "$APK" | sed -n "s/.*package name='\([^']*\)'.*/\1/p" | head -n1)
          else
            if command -v apkanalyzer >/dev/null 2>&1; then
              PKG=$(apkanalyzer manifest application-id "$APK")
            else
              echo "Neither aapt nor apkanalyzer found"; exit 1
            fi
          fi
          echo "pkg=$PKG" >> $GITHUB_OUTPUT
          echo "Detected package: $PKG"

          # Resolve real launchable activity from the package
          # (uses the default LAUNCHER activity exposed by the app)
          ACT=$(adb -s ${{ env.ANDROID_SERIAL }} shell cmd package resolve-activity -c android.intent.category.LAUNCHER "$PKG" \
                | sed -n "s/.*name=//p" | tr -d '\r' | head -n1)
          if [ -z "$ACT" ]; then
            # Fallback: common RN default
            ACT="$PKG/.MainActivity"
            echo "Fallback to $ACT"
          fi
          echo "act=$ACT" >> $GITHUB_OUTPUT
          echo "Launchable activity: $ACT"

      - name: Launch App (using resolved activity)
        id: launch
        shell: bash
        run: |
          # Record launch start time for TTJS metric
          LAUNCH_START=$(date +%s)
          echo "launch_start=$LAUNCH_START" >> $GITHUB_OUTPUT
          echo "App launch started at: $(date -d @$LAUNCH_START)"
          
          adb -s ${{ env.ANDROID_SERIAL }} shell am start -n "${{ steps.pkg.outputs.act }}" || true
          sleep 10
          adb -s ${{ env.ANDROID_SERIAL }} shell pidof "${{ steps.pkg.outputs.pkg }}" || (echo "App not running" && exit 1)

      - name: Assert React Native JS initialized + TTJS
        id: ttjs
        shell: bash
        run: |
          LAUNCH_START="${{ steps.launch.outputs.launch_start }}"
          
          # Wait up to 90s for the first JS log
          timeout 90s bash -c 'until adb -s ${{ env.ANDROID_SERIAL }} logcat -d | grep -m1 "ReactNativeJS"; do sleep 5; done'
          
          # Calculate TTJS metric
          RN_START=$(date +%s)
          TTJS_SECONDS=$((RN_START - LAUNCH_START))
          echo "ttjs_seconds=$TTJS_SECONDS" >> $GITHUB_OUTPUT
          echo "✅ ReactNativeJS detected in logcat"
          echo "📊 TTJS (Time-to-first-ReactNativeJS): ${TTJS_SECONDS}s"

      - name: Assert main activity has focus
        shell: bash
        run: |
          PKG="${{ steps.pkg.outputs.pkg }}"
          CURRENT=$(adb -s ${{ env.ANDROID_SERIAL }} shell dumpsys window | sed -n "s/.*mCurrentFocus=Window{[^ ]* [^ ]* \\([^}]*\\)}.*/\\1/p")
          echo "mCurrentFocus=$CURRENT"
          echo "$CURRENT" | grep -q "$PKG" || (echo "❌ Main activity not focused" && exit 1)

      - name: Collect deep diagnostics
        if: always()
        shell: bash
        run: |
          mkdir -p artifacts/logs
          # Full logcat since boot
          adb -s ${{ env.ANDROID_SERIAL }} logcat -d > artifacts/logs/logcat_full.txt || true
          # Trim RN-only lines for quick read
          grep -i "ReactNative" artifacts/logs/logcat_full.txt > artifacts/logs/logcat_reactnative.txt || true
          # System state
          adb -s ${{ env.ANDROID_SERIAL }} shell getprop > artifacts/logs/device_getprop.txt || true
          adb -s ${{ env.ANDROID_SERIAL }} shell settings list global > artifacts/logs/settings_global.txt || true
          adb -s ${{ env.ANDROID_SERIAL }} shell settings list system > artifacts/logs/settings_system.txt || true
          adb -s ${{ env.ANDROID_SERIAL }} shell dumpsys activity > artifacts/logs/dumpsys_activity.txt || true
          adb -s ${{ env.ANDROID_SERIAL }} shell dumpsys window > artifacts/logs/dumpsys_window.txt || true
          adb -s ${{ env.ANDROID_SERIAL }} shell dumpsys package "${{ steps.pkg.outputs.pkg }}" > artifacts/logs/dumpsys_package.txt || true
          # App process tracking  
          adb -s ${{ env.ANDROID_SERIAL }} shell pidof "${{ steps.pkg.outputs.pkg }}" > artifacts/logs/app_pid.txt || true
          # One heavy artifact for deep dive (10–30MB typical)
          adb -s ${{ env.ANDROID_SERIAL }} bugreport artifacts/logs/bugreport.zip || true

      - name: Collect ANR & tombstones (if any)
        if: always()
        shell: bash
        run: |
          mkdir -p artifacts/logs
          adb -s ${{ env.ANDROID_SERIAL }} shell ls -l /data/anr/ > artifacts/logs/anr_dir.txt 2>/dev/null || true
          # Pull ANRs if readable (emulators often allow)
          for f in $(adb -s ${{ env.ANDROID_SERIAL }} shell ls /data/anr/ 2>/dev/null | tr -d '\r'); do
            adb -s ${{ env.ANDROID_SERIAL }} shell cat "/data/anr/$f" > "artifacts/logs/anr_$f" 2>/dev/null || true
          done
          # Tombstones
          adb -s ${{ env.ANDROID_SERIAL }} shell ls -l /data/tombstones/ > artifacts/logs/tombstones_dir.txt 2>/dev/null || true
          for f in $(adb -s ${{ env.ANDROID_SERIAL }} shell ls /data/tombstones/ 2>/dev/null | tr -d '\r'); do
            adb -s ${{ env.ANDROID_SERIAL }} shell cat "/data/tombstones/$f" > "artifacts/logs/$f" 2>/dev/null || true
          done

      - name: Upload smoke logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-logs
          path: artifacts/logs/**

      - name: Summarize smoke results
        if: always()
        shell: bash
        run: |
          mkdir -p artifacts/logs
          LOG=artifacts/logs/logcat_full.txt
          RN=artifacts/logs/logcat_reactnative.txt
          SUM="$GITHUB_STEP_SUMMARY"

          echo "## Smoke Summary" >> "$SUM"
          echo "" >> "$SUM"

          # RN JS presence + TTJS metric
          if grep -q "ReactNativeJS" "$RN" 2>/dev/null; then
            echo "✅ **ReactNativeJS detected** (JS runtime initialized)" >> "$SUM"
            # Add TTJS metric if available
            if [ -n "${{ steps.ttjs.outputs.ttjs_seconds }}" ]; then
              echo "📊 **TTJS (launch → first ReactNativeJS): ${{ steps.ttjs.outputs.ttjs_seconds }}s**" >> "$SUM"
            fi
          else
            echo "❌ **No ReactNativeJS logs detected** (JS may not have started)" >> "$SUM"
          fi

          # Main failures to highlight
          echo "" >> "$SUM"
          echo "### Notable log signals" >> "$SUM"
          grep -E "FATAL EXCEPTION|Process .* has died|ANR|E ReactNative|E AndroidRuntime" "$LOG" \
            | tail -n 40 \
            | sed 's/^/- /' >> "$SUM" || true

          # APK + pkg info
          if [ -f artifacts/logs/apk_badging.txt ]; then
            VER=$(sed -n "s/.*versionName='\([^']*\)'.*/\1/p" artifacts/logs/apk_badging.txt | head -n1)
            echo "" >> "$SUM"
            echo "**APK versionName**: \`$VER\`" >> "$SUM"
          fi
          
          echo "" >> "$SUM"
          echo "**Resolved Package:** \`${{ steps.pkg.outputs.pkg }}\`" >> "$SUM"
          echo "**Launch Activity:** \`${{ steps.pkg.outputs.act }}\`" >> "$SUM"

          echo "" >> "$SUM"
          echo "_Full logs available in the **smoke-logs** artifact (includes bugreport)._ " >> "$SUM"

      - name: Emit machine-readable summary
        if: always()
        shell: bash
        run: |
          RUN_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          STATUS="$([[ "${{ job.status }}" == "success" ]] && echo success || echo failure)"
          
          # Extract TTJS and emulator boot status from step summary (still needed for smoke-specific data)
          TTJS="$(grep -oE 'TTJS[^:]*:\s*[0-9.]+s' "$GITHUB_STEP_SUMMARY" | head -n1 | sed 's/.*:\s*//' || true)"
          BOOT="$(grep -oE 'Emulator Boot:\s*✅.*|Emulator Boot:\s*❌.*' "$GITHUB_STEP_SUMMARY" | head -n1 | sed 's/^.*Emulator Boot:\s*//' || true)"
          
          echo '{' > summary.json
          echo "  \"run_id\": ${GITHUB_RUN_ID}," >> summary.json
          echo "  \"run_url\": \"${RUN_URL}\"," >> summary.json
          echo "  \"status\": \"${STATUS}\"," >> summary.json
          echo "  \"build\": { \"apk_debug_mb\": \"${APK_DEBUG_MB:-}\", \"apk_release_mb\": \"${APK_RELEASE_MB:-}\" }," >> summary.json
          echo "  \"smoke\": { \"ttjs_s\": \"${TTJS:-}\", \"emulator_boot\": \"${BOOT:-}\", \"sdk_min\": \"${SDK_MIN:-}\", \"sdk_target\": \"${SDK_TARGET:-}\" }" >> summary.json
          echo '}' >> summary.json

      - name: Upload quick summary
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: summary
          path: summary.json


